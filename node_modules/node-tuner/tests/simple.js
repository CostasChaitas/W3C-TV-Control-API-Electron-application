const fs = require('fs');
const path = require('path');

const test = require('tape');
const when = require('when');
const config = require('config');

const Tuner = require('..');

// helpers
function startAndStop(tuner, iterations) {
  return when.promise((ok, ko) => {
    tuner.start({}).then(() => {
      console.log('started.');
    }).catch(ko);

    setTimeout(() => {
      tuner.stop().then(() => {
        console.log('stoped.');
        if (!iterations || iterations <= 1) {
          return ok();
        }
        return setTimeout(startAndStop.bind(this, iterations - 1), config.TEST_TUNE_TIMEOUT_S * 1000);
      }).catch(ko);
    }, config.TEST_TUNE_TIMEOUT_S * 1000);
  });
}

test('Retrieve available tuners', (assert) => {
  const tuner = new Tuner();

  tuner.on('error', (e) => {
    console.error(e);
  });

  tuner.tuners().then((tuners) => {
    console.log(tuners);
    assert.pass(`Tuners (Count: ${tuners.length}) retrieved successfully.`);
    assert.end();
  }).catch(() => {
    assert.fail('Failed to retrieve tuners successfully. Probably no tuners attached.');
    assert.end();
  });
});

test('Retrieve tuner information', (assert) => {
  const tuner = new Tuner();

  tuner.on('error', (e) => {
    console.error(e);
  });

  tuner.tuners().then((tuners) => {
    assert.plan(tuners.length);
    tuners.forEach(_tuner => {
      tuner.info(_tuner).then((info) => {
        console.log(info);
        assert.pass('Tuner info retrieved successfully.');
      }).catch(() => {
        assert.fail('Failed to retrieve tuner information successfully.');
        assert.end();
      });
    });
  }).catch(() => {
    assert.fail('Failed to retrieve tuners successfully. Probably no tuners attached.');
    assert.end();
  });
});

test(`Start tuner and stop after some seconds (${config.TEST_TUNE_TIMEOUT_S}s)`, (assert) => {
  const tuner = new Tuner();

  tuner.on('error', (e) => {
    console.error(e);
  });

  tuner.on('status', (s) => {
    console.log(s);
  });

  startAndStop(tuner, 1).then(() => {
    assert.pass('Tuner started and stopped successfully.');
    assert.end();
  }).catch(() => {
    assert.fail('Tuner failed to start and stopp successfully.');
    assert.end();
  });
});

test(`Record some seconds (${config.TEST_TUNE_TIMEOUT_S}s) of the multiplex transport stream`, (assert) => {
  const tuner = new Tuner();
  const tmpFile = path.join(__dirname, 'dump.ts');

  tuner.on('error', (e) => {
    console.error(e);
  });

  tuner.on('status', (s) => {
    console.log(s);
  });

  tuner.pipe(fs.createWriteStream(tmpFile));

  startAndStop(tuner, 1).then(() => {
    assert.pass('TS recorded successfully.');
    // could even check here if the recorded ts file is not empty
    // but in case of no reception the test would fail
    //fs.unlink(tmpFile);
    assert.end();
  }).catch(() => {
    assert.fail('Failed to record TS successfully.');
    assert.end();
  });
});

test(`Track the bitrate for some seconds (${config.TEST_TUNE_TIMEOUT_S}s)`, (assert) => {
  const tuner = new Tuner();
  const monitor = new Tuner.BitrateMonitor();
  const sink = new Tuner.NullSink();
  let bitRateEvents = 0;

  tuner.on('error', (e) => {
    console.log('event error', e);
  });

  tuner.on('status', (s) => {
    //console.log(s);
  });

  monitor.on('bitrate', (r) => {
    bitRateEvents++;
    console.log(`Bitrate ${r} Bit/s`);
  });

  tuner.pipe(monitor).pipe(sink);

  startAndStop(tuner, 1).then(() => {
    monitor.unpipe();
    tuner.unpipe();
    assert.notEqual(bitRateEvents, 0, 'Bitrate tracked successfully');
    assert.end();
  }).catch(() => {
    assert.fail('Failed to track bitrate.');
    assert.end();
  });
});
