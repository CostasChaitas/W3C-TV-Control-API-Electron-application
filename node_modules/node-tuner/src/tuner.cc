// (c) 2016 Fraunhofer Institute for Open Communication Systems (FOKUS)
// See LICENSE.md for more information
//
#include <nan.h>
extern "C" {
#include "tunerctrl.h"
}
using namespace Nan;
NAN_METHOD(openDevice){
  int ret;
  int adapter;
  dvb_device_type_t type;
  int typeInt;
  int device;
  int flags;
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  if (info.Length() < 4) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  adapter = info[0]->NumberValue();
  typeInt = info[1]->NumberValue();
  switch(typeInt){
    case FRONTEND:
      type = FRONTEND;
      break;
    case DEMUX:
      type = DEMUX;
      break;
    case DVR:
      type = DVR;
      break;
    default:
      Nan::ThrowTypeError("Invalid arguments");
      return;
  }
  device = info[2]->NumberValue();
  flags = info[3]->NumberValue();
  ret = open_device(adapter, type, device, flags);
  if(ret < 0) {
    obj->Set(Nan::New("error").ToLocalChecked(), Nan::True());
    info.GetReturnValue().Set(obj);
    return;
  }
  obj->Set(Nan::New("error").ToLocalChecked(), Nan::False());
  obj->Set(Nan::New("fd").ToLocalChecked(), Nan::New(ret));
  info.GetReturnValue().Set(obj);
}
NAN_METHOD(closeDevice){
  int ret;
  int fd;
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  if (info.Length() < 1) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  fd = info[0]->NumberValue();
  ret = close_device(fd);
  if(ret < 0) {
    obj->Set(Nan::New("error").ToLocalChecked(), Nan::True());
    info.GetReturnValue().Set(obj);
    return;
  }
  obj->Set(Nan::New("error").ToLocalChecked(), Nan::False());
  obj->Set(Nan::New("fd").ToLocalChecked(), Nan::New(fd));
  info.GetReturnValue().Set(obj);
}
NAN_METHOD(getInfo){
  struct dvb_frontend_info fe_info;
  int ret;
  int frontend_fd;
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  if (info.Length() < 1) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  frontend_fd = info[0]->NumberValue();
  ret = get_info(frontend_fd, &fe_info);
  if(ret != 0) {
    obj->Set(Nan::New("error").ToLocalChecked(), Nan::True());
	  info.GetReturnValue().Set(obj);
	  return;
  }
  obj->Set(Nan::New("error").ToLocalChecked(), Nan::False());
  // https://linuxtv.org/downloads/v4l-dvb-apis/FE_GET_INFO.html#dvb-frontend-info
  obj->Set(Nan::New("name").ToLocalChecked(), Nan::New(fe_info.name).ToLocalChecked());
  //obj->Set(Nan::New("frequency_min").ToLocalChecked(), Nan::New(fe_info.frequency_min));
  obj->Set(Nan::New("frequency_min").ToLocalChecked(), Nan::New(522));
  obj->Set(Nan::New("frequency_max").ToLocalChecked(), Nan::New(fe_info.frequency_max));
  obj->Set(Nan::New("frequency_stepsize").ToLocalChecked(), Nan::New(fe_info.frequency_stepsize));
  obj->Set(Nan::New("frequency_tolerance").ToLocalChecked(), Nan::New(fe_info.frequency_tolerance));
  obj->Set(Nan::New("symbol_rate_min").ToLocalChecked(), Nan::New(fe_info.symbol_rate_min));
  obj->Set(Nan::New("symbol_rate_max").ToLocalChecked(), Nan::New(fe_info.symbol_rate_max));
  obj->Set(Nan::New("symbol_rate_tolerance").ToLocalChecked(), Nan::New(fe_info.symbol_rate_tolerance));
  v8::Local<v8::Object> caps = Nan::New<v8::Object>();
  caps->Set(Nan::New("FE_IS_STUPID").ToLocalChecked(), (fe_info.caps & FE_IS_STUPID) == FE_IS_STUPID ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_INVERSION_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_INVERSION_AUTO) == FE_CAN_INVERSION_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_1_2").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_1_2) == FE_CAN_FEC_1_2 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_2_3").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_2_3) == FE_CAN_FEC_2_3 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_3_4").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_3_4) == FE_CAN_FEC_3_4 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_4_5").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_4_5) == FE_CAN_FEC_4_5 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_5_6").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_5_6) == FE_CAN_FEC_5_6 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_6_7").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_6_7) == FE_CAN_FEC_6_7 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_7_8").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_7_8) == FE_CAN_FEC_7_8 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_8_9").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_8_9) == FE_CAN_FEC_8_9 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_FEC_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_FEC_AUTO) == FE_CAN_FEC_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QPSK").ToLocalChecked(), (fe_info.caps & FE_CAN_QPSK) == FE_CAN_QPSK ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QAM_16").ToLocalChecked(), (fe_info.caps & FE_CAN_QAM_16) == FE_CAN_QAM_16 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QAM_32").ToLocalChecked(), (fe_info.caps & FE_CAN_QAM_32) == FE_CAN_QAM_32 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QAM_64").ToLocalChecked(), (fe_info.caps & FE_CAN_QAM_64) == FE_CAN_QAM_64 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QAM_128").ToLocalChecked(), (fe_info.caps & FE_CAN_QAM_128) == FE_CAN_QAM_128 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QAM_256").ToLocalChecked(), (fe_info.caps & FE_CAN_QAM_256) == FE_CAN_QAM_256 ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_QAM_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_QAM_AUTO) == FE_CAN_QAM_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_TRANSMISSION_MODE_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_TRANSMISSION_MODE_AUTO) == FE_CAN_TRANSMISSION_MODE_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_BANDWIDTH_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_BANDWIDTH_AUTO) == FE_CAN_BANDWIDTH_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_GUARD_INTERVAL_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_GUARD_INTERVAL_AUTO) == FE_CAN_GUARD_INTERVAL_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_HIERARCHY_AUTO").ToLocalChecked(), (fe_info.caps & FE_CAN_HIERARCHY_AUTO) == FE_CAN_HIERARCHY_AUTO ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_8VSB").ToLocalChecked(), (fe_info.caps & FE_CAN_8VSB) == FE_CAN_8VSB ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_16VSB").ToLocalChecked(), (fe_info.caps & FE_CAN_16VSB) == FE_CAN_16VSB ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_HAS_EXTENDED_CAPS").ToLocalChecked(), (fe_info.caps & FE_HAS_EXTENDED_CAPS) == FE_HAS_EXTENDED_CAPS ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_MULTISTREAM").ToLocalChecked(), (fe_info.caps & FE_CAN_MULTISTREAM) == FE_CAN_MULTISTREAM ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_TURBO_FEC").ToLocalChecked(), (fe_info.caps & FE_CAN_TURBO_FEC) == FE_CAN_TURBO_FEC ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_2G_MODULATION").ToLocalChecked(), (fe_info.caps & FE_CAN_2G_MODULATION) == FE_CAN_2G_MODULATION ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_RECOVER").ToLocalChecked(), (fe_info.caps & FE_CAN_RECOVER) == FE_CAN_RECOVER ? Nan::True() : Nan::False());
  caps->Set(Nan::New("FE_CAN_MUTE_TS").ToLocalChecked(), (fe_info.caps & FE_CAN_MUTE_TS) == FE_CAN_MUTE_TS ? Nan::True() : Nan::False());
  obj->Set(Nan::New("caps").ToLocalChecked(), caps);
  info.GetReturnValue().Set(obj);
}
NAN_METHOD(setFrontend){
  int ret;
  int frontend_fd;
  struct transponder * pt;
  struct transponder t;
  pt=&t;
  memset(pt, 0, sizeof(t));
  if (info.Length() < 2) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  frontend_fd = info[0]->NumberValue();
  v8::Local<v8::Object> obj = info[1].As<v8::Object>();
  fe_delivery_system_t delsys;
  int _delsys = Nan::Get(obj, Nan::New("delsys").ToLocalChecked()).ToLocalChecked()->NumberValue();
  switch(_delsys) {
    case SYS_DVBT2:
      delsys = SYS_DVBT2;
    break;
    case SYS_DVBT:
      delsys = SYS_DVBT;
    break;
    default:
      Nan::ThrowTypeError("Invalid arguments");
      return;
    break;
  }
  uint32_t frequency = Nan::Get(obj, Nan::New("frequency").ToLocalChecked()).ToLocalChecked()->NumberValue();
  uint32_t bandwidth = Nan::Get(obj, Nan::New("bandwidth").ToLocalChecked()).ToLocalChecked()->NumberValue();
  t.type              = SCAN_TERRESTRIAL;
  t.delsys            = delsys;
  t.plp_id            = 0;
  t.frequency         = frequency;
  t.inversion         = INVERSION_AUTO;
  t.bandwidth         = bandwidth;
  t.coderate          = FEC_AUTO;
  t.coderate_LP       = FEC_AUTO;
  t.modulation        = QAM_AUTO;
  t.transmission      = TRANSMISSION_MODE_AUTO;
  t.guard             = GUARD_INTERVAL_AUTO;
  t.hierarchy         = HIERARCHY_AUTO;
  ret = set_frontend(frontend_fd, pt);
  v8::Local<v8::Number> num = Nan::New(ret);
  info.GetReturnValue().Set(num);
}
NAN_METHOD(readStatus){
  int ret;
  int frontend_fd;
  fe_status_t * pstatus;
  fe_status_t status;
  pstatus=&status;
  memset(pstatus, 0, sizeof(status));
  if (info.Length() != 1) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  frontend_fd = info[0]->NumberValue();
  ret = check_frontend(frontend_fd, pstatus);
  v8::Local<v8::Object> obj = Nan::New<v8::Object>();
  // https://linuxtv.org/downloads/v4l-dvb-apis/FE_GET_INFO.html#dvb-frontend-info
  if(ret == 0 ){
    obj->Set(Nan::New("error").ToLocalChecked(), Nan::False());
    obj->Set(Nan::New("FE_HAS_SIGNAL").ToLocalChecked(), (status & FE_HAS_SIGNAL) ? Nan::True() : Nan::False());
    obj->Set(Nan::New("FE_HAS_CARRIER").ToLocalChecked(), (status & FE_HAS_CARRIER) ? Nan::True() : Nan::False());
    obj->Set(Nan::New("FE_HAS_VITERBI").ToLocalChecked(), (status & FE_HAS_VITERBI) ? Nan::True() : Nan::False());
    obj->Set(Nan::New("FE_HAS_SYNC").ToLocalChecked(), (status & FE_HAS_SYNC) ? Nan::True() : Nan::False());
    obj->Set(Nan::New("FE_HAS_LOCK").ToLocalChecked(), (status & FE_HAS_LOCK) ? Nan::True() : Nan::False());
    obj->Set(Nan::New("FE_TIMEDOUT").ToLocalChecked(), (status & FE_TIMEDOUT) ? Nan::True() : Nan::False());
    obj->Set(Nan::New("FE_REINIT").ToLocalChecked(), (status & FE_REINIT) ? Nan::True() : Nan::False());
    if(status & FE_HAS_LOCK) {
      int  cnr = 0;
      int  cnrdB = 0;
      int  sgnl = 0;
      int  sgnldB = 0;
      int preErrorBitCount = 0;
      int preTotalBitCount = 0;
      int postErrorBitCount = 0;
      int postTotalBitCount = 0;
      int errorBlockCount = 0;
      int errorTotalCount = 0;
      if(get_props(frontend_fd, &sgnl, &sgnldB, &cnr, &cnrdB,
        &preErrorBitCount, &preTotalBitCount,
        &postErrorBitCount, &postTotalBitCount,
        &errorBlockCount, &errorTotalCount) == 0){
        obj->Set(Nan::New("cnr").ToLocalChecked(), Nan::New(cnr));
        obj->Set(Nan::New("cnrdB").ToLocalChecked(), Nan::New(cnrdB));
        obj->Set(Nan::New("signalStrength").ToLocalChecked(), Nan::New(sgnl));
        obj->Set(Nan::New("signalStrengthdB").ToLocalChecked(), Nan::New(sgnldB));
        obj->Set(Nan::New("preErrorBitCount").ToLocalChecked(), Nan::New(preErrorBitCount));
        obj->Set(Nan::New("preTotalBitCount").ToLocalChecked(), Nan::New(preTotalBitCount));
        obj->Set(Nan::New("postErrorBitCount").ToLocalChecked(), Nan::New(postErrorBitCount));
        obj->Set(Nan::New("postTotalBitCount").ToLocalChecked(), Nan::New(postTotalBitCount));
        obj->Set(Nan::New("errorBlockCount").ToLocalChecked(), Nan::New(errorBlockCount));
        obj->Set(Nan::New("errorTotalCount").ToLocalChecked(), Nan::New(errorTotalCount));
      }
    }
  } else {
    obj->Set(Nan::New("error").ToLocalChecked(), Nan::True());
  }
  info.GetReturnValue().Set(obj);
}
NAN_METHOD(startStream){
  int ret;
  int demux_fd;
  if (info.Length() != 1) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  demux_fd = info[0]->NumberValue();
  ret = start_stream(demux_fd);
  v8::Local<v8::Number> num = Nan::New(ret);
  info.GetReturnValue().Set(num);
}
NAN_METHOD(stopStream){
  int ret;
  int demux_fd;
  if (info.Length() != 1) {
    Nan::ThrowTypeError("Wrong number of arguments");
    return;
  }
  demux_fd = info[0]->NumberValue();
  ret = stop_stream(demux_fd);
  v8::Local<v8::Number> num = Nan::New(ret);
  info.GetReturnValue().Set(num);
}
NAN_MODULE_INIT(Init) {
  NAN_EXPORT(target, openDevice);
  NAN_EXPORT(target, closeDevice);
  NAN_EXPORT(target, getInfo);
  NAN_EXPORT(target, setFrontend);
  NAN_EXPORT(target, readStatus);
  NAN_EXPORT(target, startStream);
  NAN_EXPORT(target, stopStream);
      // export of constants
  Set(target, New<v8::String>("SYS_DVBT2").ToLocalChecked(), Nan::New(SYS_DVBT2));
  Set(target, New<v8::String>("SYS_DVBT").ToLocalChecked(), Nan::New(SYS_DVBT));
  Set(target, New<v8::String>("FRONTEND").ToLocalChecked(), Nan::New(FRONTEND));
  Set(target, New<v8::String>("DEMUX").ToLocalChecked(), Nan::New(DEMUX));
  Set(target, New<v8::String>("DVR").ToLocalChecked(), Nan::New(DVR));
}
NODE_MODULE(tuner, Init)
