// (c) 2016 Fraunhofer Institute for Open Communication Systems (FOKUS)
// See LICENSE.md for more information
//

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <assert.h>
#include <getopt.h>
#include <errno.h>
#include <linux/dvb/dmx.h>
#include <linux/dvb/version.h>

#include "tunerctrl.h"

int open_device(int adapter, dvb_device_type_t type, int device, int flags){
  int fd;
  char devname [80];
  switch(type){
    case FRONTEND:
      snprintf(devname, sizeof(devname), "/dev/dvb/adapter%i/frontend%i", adapter, device);
      break;
    case DEMUX:
      snprintf(devname, sizeof(devname), "/dev/dvb/adapter%i/demux%i", adapter, device);
      break;
    case DVR:
      snprintf(devname, sizeof(devname), "/dev/dvb/adapter%i/dvr%i", adapter, device);
      break;
    default:
      return -1;
  }
  if ((fd = open(devname, flags)) < 0){
     return -1;
  }
  return fd;
}

int close_device(int fd){
  int ret;

  ret = close(fd);
  if( ret != 0) {
    // errno check
  }
  return ret;
}

int get_info(int frontend_fd, struct dvb_frontend_info  * fe_info){
	return ioctl(frontend_fd, FE_GET_INFO, fe_info);
}

int set_frontend(int frontend_fd, struct transponder * t) {
  //uint8_t switch_to_high_band = 0;
  uint32_t intermediate_freq = 0;
  int sequence_len = 0;
  struct dtv_property cmds[13];
  struct dtv_properties cmdseq = {0, cmds};

  // if (mem_is_zero(&t->param, sizeof(struct tuning_parameters)))
  //    return -1;

  //switch(flags.api_version) {
  switch(0x0500) {
     case 0x0500 ... 0x05FF:
        //debug("%s: using DVB API %u.%u\n",
        //  __FUNCTION__,
        // flags.api_version >> 8,
        // flags.api_version & 0xFF);

        /* some 'shortcut' here :-)) --wk 20090324 */
        #define set_cmd_sequence(_cmd, _data)   cmds[sequence_len].cmd = _cmd; \
                                                cmds[sequence_len].u.data = _data; \
                                                cmdseq.num = ++sequence_len

        set_cmd_sequence(DTV_CLEAR, DTV_UNDEFINED);
        switch(t->type) {
           case SCAN_SATELLITE:
              set_cmd_sequence(DTV_DELIVERY_SYSTEM,   t->delsys);
              set_cmd_sequence(DTV_FREQUENCY,         intermediate_freq);
              set_cmd_sequence(DTV_INVERSION,         t->inversion);
              set_cmd_sequence(DTV_MODULATION,        t->modulation);
              set_cmd_sequence(DTV_SYMBOL_RATE,       t->symbolrate);
              set_cmd_sequence(DTV_INNER_FEC,         t->coderate);
              set_cmd_sequence(DTV_PILOT,             t->pilot);
              set_cmd_sequence(DTV_ROLLOFF,           t->rolloff);
              break;
           case SCAN_CABLE:
              set_cmd_sequence(DTV_DELIVERY_SYSTEM,   t->delsys);
              set_cmd_sequence(DTV_FREQUENCY,         t->frequency);
              set_cmd_sequence(DTV_INVERSION,         t->inversion);
              set_cmd_sequence(DTV_MODULATION,        t->modulation);
              set_cmd_sequence(DTV_SYMBOL_RATE,       t->symbolrate);
              set_cmd_sequence(DTV_INNER_FEC,         t->coderate);
              break;
           case SCAN_TERRESTRIAL:
              set_cmd_sequence(DTV_DELIVERY_SYSTEM,   t->delsys);
              if (t->delsys == SYS_DVBT2) {
                 set_cmd_sequence(DTV_STREAM_ID, t->plp_id);
                 }
              set_cmd_sequence(DTV_FREQUENCY,         t->frequency);
              set_cmd_sequence(DTV_INVERSION,         t->inversion);
              set_cmd_sequence(DTV_BANDWIDTH_HZ,      t->bandwidth);
              set_cmd_sequence(DTV_CODE_RATE_HP,      t->coderate);
              set_cmd_sequence(DTV_CODE_RATE_LP,      t->coderate_LP);
              set_cmd_sequence(DTV_MODULATION,        t->modulation);
              set_cmd_sequence(DTV_TRANSMISSION_MODE, t->transmission);
              set_cmd_sequence(DTV_GUARD_INTERVAL,    t->guard);
              set_cmd_sequence(DTV_HIERARCHY,         t->hierarchy);
              break;
           case SCAN_TERRCABLE_ATSC:
              set_cmd_sequence(DTV_DELIVERY_SYSTEM,   t->delsys);
              set_cmd_sequence(DTV_FREQUENCY,         t->frequency);
              set_cmd_sequence(DTV_INVERSION,         t->inversion);
              set_cmd_sequence(DTV_MODULATION,        t->modulation);
              break;
           default:
           ;
              //fatal("Unhandled type %d\n", t->type);
           }
        set_cmd_sequence(DTV_TUNE, DTV_UNDEFINED);
        //EMUL(em_setproperty, &cmdseq)
        if(ioctl(frontend_fd, FE_SET_PROPERTY, &cmdseq) < 0){
          printf("errno %d", errno);
          return -1;
        }
        return 0;
        break;
     default:
     ;
        //fatal("unsupported DVB API Version %d.%d\n", flags.api_version >> 8, flags.api_version & 0xFF);
     }
  return -2;
}

int check_frontend(int fd, fe_status_t * status) {
  return ioctl(fd, FE_READ_STATUS, status);
}

int get_props(int fd, int * sgnl, int * sgnldB, int * cnr, int * cnrdB,
  int * preErrorBitCount, int * preTotalBitCount,
  int * postErrorBitCount, int * postTotalBitCount,
  int * errorBlockCount, int * errorTotalCount) {
  unsigned int i;
  struct dtv_properties props;
  struct dtv_property prop[8];
  prop[0].cmd = DTV_STAT_SIGNAL_STRENGTH;
  prop[1].cmd = DTV_STAT_CNR;
  prop[2].cmd = DTV_STAT_PRE_ERROR_BIT_COUNT;
  prop[3].cmd = DTV_STAT_PRE_TOTAL_BIT_COUNT;
  prop[4].cmd = DTV_STAT_POST_ERROR_BIT_COUNT;
  prop[5].cmd = DTV_STAT_POST_TOTAL_BIT_COUNT;
  prop[6].cmd = DTV_STAT_ERROR_BLOCK_COUNT;
  prop[7].cmd = DTV_STAT_TOTAL_BLOCK_COUNT;


  props.props = prop;
  props.num = 8;

  if (ioctl(fd, FE_GET_PROPERTY, &props) < 0) {
    return -1;
  } else {
    for(i=0; i<prop[0].u.st.len; i++)
    {
      if (prop[0].u.st.stat[i].scale == FE_SCALE_DECIBEL)
        *sgnldB = prop[0].u.st.stat[i].svalue;
      else if (prop[0].u.st.stat[i].scale == FE_SCALE_RELATIVE)
        *sgnl = prop[0].u.st.stat[i].uvalue;
    }
    for(i=0; i<prop[1].u.st.len; i++)
    {
      if (prop[1].u.st.stat[i].scale == FE_SCALE_DECIBEL)
        *cnrdB = prop[1].u.st.stat[i].svalue;
      else if (prop[1].u.st.stat[i].scale == FE_SCALE_RELATIVE)
        *cnr = prop[1].u.st.stat[i].uvalue;
    }

    // the following stats seem not to be implemented by the SiLabs firmware :(
    for(i=0; i<prop[2].u.st.len; i++)
    {
      if (prop[2].u.st.stat[i].scale == FE_SCALE_COUNTER)
        *preErrorBitCount = prop[2].u.st.stat[i].uvalue;
    }
    for(i=0; i<prop[3].u.st.len; i++)
    {
      if (prop[3].u.st.stat[i].scale == FE_SCALE_COUNTER)
        *preTotalBitCount = prop[3].u.st.stat[i].uvalue;
    }

    for(i=0; i<prop[4].u.st.len; i++)
    {
      if (prop[4].u.st.stat[i].scale == FE_SCALE_COUNTER)
        *postErrorBitCount = prop[4].u.st.stat[i].uvalue;
    }
    for(i=0; i<prop[5].u.st.len; i++)
    {
      if (prop[5].u.st.stat[i].scale == FE_SCALE_COUNTER)
        *postTotalBitCount = prop[5].u.st.stat[i].uvalue;
    }
    for(i=0; i<prop[6].u.st.len; i++)
    {
      if (prop[6].u.st.stat[i].scale == FE_SCALE_COUNTER)
        *errorBlockCount = prop[6].u.st.stat[i].uvalue;
    }
    for(i=0; i<prop[7].u.st.len; i++)
    {
      if (prop[7].u.st.stat[i].scale == FE_SCALE_COUNTER)
        *errorTotalCount = prop[7].u.st.stat[i].uvalue;
    }
  }
  return 0;
}

int start_stream(int fd) {
 struct dmx_pes_filter_params pesFilterParams;
 if (ioctl(fd, DMX_SET_BUFFER_SIZE, 1024 * 188) < 0) {
  return -1;
 }
 memset(&pesFilterParams, 0, sizeof(pesFilterParams));
 pesFilterParams.pid = 0x2000;
 pesFilterParams.input = DMX_IN_FRONTEND;
 pesFilterParams.output = DMX_OUT_TAP;
 pesFilterParams.pes_type = DMX_PES_OTHER;
 pesFilterParams.flags = DMX_IMMEDIATE_START;
 return ioctl(fd, DMX_SET_PES_FILTER, &pesFilterParams);
}

int stop_stream(int fd) {
  return ioctl(fd, DMX_STOP);
}


int main( int argc, const char* argv[] ){
  int fd;
  int dd;
  int ret;
  struct transponder * pt;
  struct transponder t;
  pt=&t;
  memset(pt, 0, sizeof(t));

  fd = open_device(0, FRONTEND, 0, O_RDWR | O_NONBLOCK);
  if(fd<0) {
      perror("FRONTEND OPEN");
      return -1;
  }
  t.type              = SCAN_TERRESTRIAL;
  t.delsys            = SYS_DVBT2;
  t.plp_id            = 0;
  t.frequency         = 642000000;
  t.inversion         = INVERSION_AUTO;
  t.bandwidth         = 8000000;
  t.coderate          = FEC_AUTO;
  t.coderate_LP       = FEC_AUTO;
  t.modulation        = QAM_AUTO;
  t.transmission      = TRANSMISSION_MODE_AUTO;
  t.guard             = GUARD_INTERVAL_AUTO;
  t.hierarchy         = HIERARCHY_AUTO;

  ret = set_frontend(fd, pt);
  if(ret<0) {
      perror("FRONTEND SET");
      return -1;
  }

  dd = open_device(0, DEMUX, 0, O_RDONLY | O_NONBLOCK);
  if(dd < 0) {
      perror("DEMUX OPEN");
      return -1;
  }
  ret = start_stream(dd);
    if(ret<0) {
      perror("DEMUX SET FILTER, START STREAM");
      return -1;
  }

  usleep(20000);
  ret = stop_stream(dd);
    if(ret<0) {
      perror("DEMUX SET FILTER, STOP STREAM");
      return -1;
  }
  close(dd);
  close(fd);
  return 0;
}
