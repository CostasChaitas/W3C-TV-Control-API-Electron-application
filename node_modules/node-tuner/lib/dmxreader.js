const fork = require('child_process').fork;
const fs = require('fs');
const path = require('path');
const mkfifo = require('mkfifo').mkfifo;
const config = require('config');
const when = require('when');

class DMXReader {
  constructor(fd) {
    this._demux_fd = fd;
    this._fifo = `fifo-${fd}`;
    this._slidingBuffer = [];
    this._readRequested = false;
    mkfifo(this._fifo, parseInt('0600', 8), (err) => {
      if (err) {
        console.log('error creating fifo for demux reading', err);
      }
      this.rs = fs.createReadStream(this._fifo);
      this.rs.on('data', (chunk) => {
        if (!this._readRequested || !this._child) return;
        this._slidingBuffer.push(chunk);
        if (this._slidingBuffer.length > config.READ_BUFFER_SLOTS) {
          console.log('buffer is consumed too slowly');
          this._slidingBuffer.splice(0, 1);
        }
      });
      this.rs.on('error', (error) => {
        console.log('error: ', error);
      });
      this.rs.on('close', () => {
        if (this._child) {
          this._child.send({
            action: 'stop',
          });
        }
      });
    });
  }
  read(size, cb) {
    this._readRequested = true;
    if (this._slidingBuffer.length) {
      return cb(null, this._slidingBuffer.splice(0, 1)[0]);
    }
    // closed already?
    if (!this._child) {
      return cb({
        code: 400,
      });
    }
    // read buffer empty
    return cb({
      code: 404,
    });
  }
  start() {
    return when.promise((ok, ko) => {
      this._child = fork(path.join(__dirname, 'dmxreader.child.js'), [this._demux_fd, this._fifo]);
      this._child.on('close', (code) => {
        if (!code) {
          ko({
            ts: Date.now(),
            unit: 'dmxreader:start',
            code: 500,
            error: new Error('start: could not fork child'),
          });
        }
        this.close().then(() => {}).catch(() => {});
      });
      this._child.send({
        action: 'start',
      });
      this._child.on('message', (m) => {
        if (m && m.code === 200) {
          ok();
        } else {
          ko(m);
        }
      });
    });
  }
  close() {
    return when.promise((ok, ko) => {
      if (!this._child) {
        return ko({
          unit: 'dmxreader:close',
          code: 400,
        });
      }
      this.rs.close();
      this._child.on('close', (code) => {
        fs.unlink(this._fifo);
        return ok({
          code,
        });
      });
      this._child.kill();
      this._child = null;
      return null;
    });
  }

}

module.exports = DMXReader;
