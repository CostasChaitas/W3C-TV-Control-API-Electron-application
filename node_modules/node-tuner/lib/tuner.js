'use strict';
// (c) 2016 Fraunhofer Institute for Open Communication Systems (FOKUS)
// See LICENSE.md for more information
//

// This module is currently explicitely for Linux
if (process.platform !== 'linux') {
  throw new Error(`Currently only the linux platform is supported. Yours is ${process.platform}`);
}

/**
 * Simple streaming API for DVB tuner bindings
 * @module node-tuner
 * @requires bindings, nan
 * @author Martin Lasak <martin.lasak@fokus.fraunhofer.de>
 */
const Readable = require('stream').Readable;
const fs = require('fs');
const path = require('path');
const constants = require('constants');

const tuner = require('bindings')('tuner');
const DMXReader = require('./dmxreader.js');

const config = require('config');
const when = require('when');

const DEVICES_LOCATION = '/dev/dvb';

/**
 * The tuner. Stream-based.
 * @class
 * @extends Readable
 * @fires error, status, start, stop
 */
class Tuner extends Readable {
  constructor(options) {
    const _opt = {
      highWaterMark: config.READ_BUFFER_SIZE,
    };
    Object.keys(options || {}).forEach(key => {
      _opt[key] = options[key];
    });
    super(_opt);
    this._frontendFd = null;
    this._demuxFd = null;
    this._bytesWritten = 0;
  }
  _read(size) {
    // internal readable implementation
    if (this._demuxFd === null) {
      this._readRequestSize = size;
    } else {
      const status = tuner.readStatus(this._frontendFd);
      if (!status.FE_HAS_LOCK) {
        // try again after 25ms
        setTimeout(() => this._read.call(this, size), 25);
      } else {
        this._readRequestSize = null;

        this._dmxReader.read(size, (err, _chunk) => {
          if (err) {
            if (err.code === 404) {
              // read buffer was empty, try again...
              setTimeout(this._read.bind(this, size), 1);
            } else {
              this.emit('error', err);
            }
          } else {
            this._bytesWritten += _chunk.length;
            if (this.push(_chunk)) {
              // console.error('can not push more.');
            }
          }
        });
      }
    }
  }

  /**
   * Start the tuner.
   * @param {Object} options
   * @param {Number} options.adapter The number of the adapter
   * @param {Number} options.device The number of the device
   * @param {Number} options.delsys Specifies the number of the delivery system, e.g. Tuner.SYS_DVBT or Tuner.SYS_DVBT2
   * @param {Number} options.frequency Specifies the frequency to be tuned in Hz
   * @param {Number} options.bandwidth Specifies the bandwidth to be used in Hz
   * @param {Number} options.plp_id Specifies the physical layer pipe id
   */
  start(options) {
    const _opt = options || {};
    _opt.adapter = _opt.adapter || 0;
    _opt.device = _opt.frontend && _opt.frontend.length && _opt.frontend[0] || 0;
    let err;
    let result;
    this._bytesWritten = 0;
    return when.promise((ok, ko) => {
      if (this._frontendFd !== null || this._demuxFd !== null) {
        err = {
          ts: Date.now(),
          unit: 'tuner',
          code: 500,
          error: new Error('tuner: this tuner is already started'),
        };
        this.emit('error', err);
        return ko(err);
      }
      result = tuner.openDevice(_opt.adapter,
        tuner.FRONTEND,
        _opt.device,
        constants.O_RDWR);
      if (result.error) {
        console.log("HIER IST DER FEHLER!");
        console.log(result);
        err = {
          ts: Date.now(),
          unit: 'tuner:frontend',
          code: 500,
          error: new Error('frontend: device could not be opened ${result.error}'),
        };
        console.log(err);
        this.emit('error', err);
        //return ko(err);
      }

      //console.log("From tuner.js: DVBT2: " + tuner.SYS_DVBT2);
      //console.log("From tuner.js: DVBT: " + tuner.SYS_DVBT);
      this._frontendFd = result.fd;
      try {
        const ret = tuner.setFrontend(this._frontendFd, {
          delsys: _opt.delsys || tuner.SYS_DVBT2,
                frequency: _opt.frequency || 642000000,
		bandwidth: _opt.bandwidth || 8000000,
          plp_id: _opt.plp_id || 0,
        });
        if (ret) {
          err = {
            ts: Date.now(),
            unit: 'tuner:frontend',
            code: 500,
            error: new Error(`frontend: could not start the tuner ${ret}`),
          };
          this.emit('error', err);
          return ko(err);
        }
      } catch (e) {
        this.emit('error', e);
        return ko(e);
      }
      // continous status updates
      this.statusHandle = setInterval((fd) => {
        const status = tuner.readStatus(fd);
        if (status && status.error) {
          err = {
            ts: Date.now(),
            unit: 'tuner:frontend',
            code: 500,
            error: new Error('frontend: could not get the status'),
          };
          return this.emit('error', err);
        }
        return this.emit('status', status);
      }, config.SAMPLING_INTERVAL_MS, this._frontendFd);

      // open the demux file
      result = tuner.openDevice(_opt.adapter,
        tuner.DEMUX, _opt.device, constants.O_RDWR);
      if (result.error) {
        err = {
          ts: Date.now(),
          unit: 'tuner:demux',
          code: 500,
          error: new Error(`demux: device could not be opened ${result.error}`),
        };
        this.emit('error', err);
        return ko(err);
      }
      this._demuxFd = result.fd;

      const streamStartStatusError = tuner.startStream(this._demuxFd);
      if (streamStartStatusError) {
        err = {
          ts: Date.now(),
          unit: 'tuner:demux',
          code: 500,
          error: new Error(`demux: start streaming failed ${streamStartStatusError}`),
        };
        this.emit('error', err);
        return ko(err);
      }
      // open the demux file for reading
      result = tuner.openDevice(_opt.adapter,
        tuner.DEMUX, _opt.device, constants.O_RDONLY);
      if (result.error) {
        err = {
          ts: Date.now(),
          unit: 'tuner:demux',
          code: 500,
          error: new Error(`demux: device could not be opened ${result.error}`),
        };
        this.emit('error', err);
        return ko(err);
      }
      this._dmxReader = new DMXReader(this._demuxFd);
      this._dmxReader.start().then(() => {
        // start piping if user already requested so
        if (this._readRequestSize) {
          process.nextTick(() => this._read.call(this, this._readRequestSize));
        }
        this.emit('start');
        return ok();
      }).catch((errStart) => {
        this.emit('error', errStart);
        return ko(errStart);
      });
    });
  }

  /**
   * Stop the tuner. No parameters.
   */
  stop() {
    let err;
    let result;
    console.log('About to close...');
    return when.promise((ok, ko) => {
      if (this.statusHandle) {
        clearInterval(this.statusHandle);
      }
      if (this._demuxFd === null) {
        err = {
          ts: Date.now(),
          unit: 'tuner:demux',
          code: 500,
          error: new Error('demux: device already stopped'),
        };
        this.emit('error', err);
      }
      if (this._frontendFd === null) {
        err = {
          ts: Date.now(),
          unit: 'tuner:frontend',
          code: 500,
          error: new Error('frontend: device already stopped'),
        };
        this.emit('error', err);
      }
      if (err) {
        this._frontendFd = null;
        this._demuxFd = null;
        this._dmxReader.close().then(() => {}).catch(() => {});
        return ko(err);
      }
      return this._dmxReader.close().then(() => {
        result = tuner.stopStream(this._demuxFd);
        if (result) {
          err = {
            ts: Date.now(),
            unit: 'tuner:demux',
            code: 500,
            error: new Error(`demux: stop streaming failed ${result}`),
          };
          this.emit('error', err);
        }
        result = tuner.closeDevice(this._demuxFd);
        if (result.error) {
          err = {
            ts: Date.now(),
            unit: 'tuner:demux',
            code: 500,
            error: new Error(`demux: closing the device failed ${result.error}`),
          };
          this.emit('error', err);
        }

        result = tuner.closeDevice(this._frontendFd);
        if (result.error) {
          err = {
            ts: Date.now(),
            unit: 'tuner:frontend',
            code: 500,
            error: new Error(`frontend: closing the device failed ${result.error}`),
          };
          this.emit('error', err);
        }

        this._frontendFd = null;
        this._demuxFd = null;

        console.log('Bytes written: ', this._bytesWritten);
        if (err) {
          return ko(err);
        }
        return ok();
      }).catch((errc) => {
        console.log('ERROR closing', errc);
        ko(errc);
      });
    });
  }

  /**
   * Get information on the frontend.
   */
  info(options) {
    const _opt = options || {};
    _opt.adapter = _opt.adapter || 0;
    _opt.device = _opt.frontend && _opt.frontend.length && _opt.frontend[0] || 0;
    let err;
    let result;
    return when.promise((ok, ko) => {
      result = tuner.openDevice(_opt.adapter,
        tuner.FRONTEND,
        _opt.device,
        constants.O_RDONLY | constants.O_NONBLOCK);
      if (result.error) {
        err = {
          ts: Date.now(),
          unit: 'tuner:frontend',
          code: 500,
          error: new Error(`frontend: device could not be opened ${result.error}`),
        };
        this.emit('error', err);
        return ko(err);
      }
      result = tuner.getInfo(result.fd);
      if (result.error) {
        err = {
          ts: Date.now(),
          unit: 'tuner:frontend',
          code: 500,
          error: new Error('frontend: could not retrieve device information'),
        };
        this.emit('error', err);
        tuner.closeDevice(result.fd);
        return ko(err);
      }
      tuner.closeDevice(result.fd);
      return ok(result);
    });
  }

  /**
   * Get available tuners.
   */
  tuners() {
    let err;
    return when.promise((ok, ko) => {
      fs.readdir(DEVICES_LOCATION, (e, adapters) => {
        if (e || !adapters || !adapters.length) {
          err = {
            ts: Date.now(),
            unit: 'tuner',
            code: 500,
            error: new Error('tuner: could not retrieve devices. any available/plugged in?'),
          };
          this.emit('error', err);
          return ko(err);
        }
        const devices = adapters.map(adapter => when.promise((ok2) => {
          const result = {
            adapter: parseInt(/^([^\d]*)(\d+)$/.exec(adapter)[2], 10) || undefined,
          };
          fs.readdir(path.join(DEVICES_LOCATION, adapter), (e2, _devices) => {
            if (e2 || !_devices || !_devices.length) {
              return;
            }
            _devices.forEach(dev => {
              const matches = /^([^\d]*)(\d+)$/.exec(dev);
              if (matches.length === 3) {
                if (result[matches[1]]) {
                  result[matches[1]].push(parseInt(matches[2], 10));
                } else {
                  result[matches[1]] = [parseInt(matches[2], 10)];
                }
              }
            });
            ok2(result);
          });
        }));
        return when.all(devices).then(ok);
      });
    });
  }
}


module.exports = Tuner;
module.exports.BitrateMonitor = require('./bitratemonitor.js');
module.exports.NullSink = require('./nullsink.js');
