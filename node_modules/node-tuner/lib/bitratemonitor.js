'use strict';
// (c) 2016 Fraunhofer Institute for Open Communication Systems (FOKUS)
// See LICENSE.md for more information
//

const Transform = require('stream').Transform;

class BitrateMonitor extends Transform {
  constructor(options) {
    super(options);
    this._currentBitrate = 0;
    this._dataTotal = 0;
    this._t1 = Date.now();
    this._timeoutHandler = null;
    this.on('unpipe', () => {
      this._cleanup();
    });
    this.on('pipe', () => {
      this.emit('bitrate', this._currentBitrate);
    });
  }
  get bitrate() {
    return this._currentBitrate;
  }
  _calc() {
    this._cleanup();
    this._t2 = Date.now();
    if (this._t1 + 1000 <= this._t2) {
      this._currentBitrate = (1000 / (this._t2 - this._t1)) * (8 * this._dataTotal) >> 0;
      this._dataTotal = 0;
      this._t1 = Date.now();
      this.emit('bitrate', this._currentBitrate);
    }
    // in case there is no new chunks incoming, we calc after a second only once...
    if (this._currentBitrate > 1) {
      this._timeoutHandler = setTimeout(this._calc.bind(this), 1000);
    }
  }
  _transform(chunk, encoding, callback) {
    this._dataTotal += chunk.length;
    this._calc();
    callback(null, chunk);
  }
  _flush(callback) {
    this._cleanup();
    callback();
  }
  _cleanup() {
    if (this._timeoutHandler) {
      clearTimeout(this._timeoutHandler);
    }
  }
}

module.exports = BitrateMonitor;
